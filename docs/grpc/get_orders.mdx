---
title: 'Fetch User Orders'
description: 'Retrieving user order history via gRPC'
---

<Note>
  This example shows how to call the `GetUserOrders` RPC to fetch your order history.
</Note>

## Example: Fetching User Orders

<CodeGroup>
```python python
import grpc
from common_pb2 import ListRequest
import port_pb2_grpc


def fetch_user_orders(limit: int = 50):
    metadata = (('api-key', API_KEY),)
    channel = grpc.secure_channel('trade.pfex.io:443', grpc.ssl_channel_credentials())
    stub = port_pb2_grpc.PortServiceStub(channel)
    request = ListRequest(limit=limit)
    response = stub.GetUserOrders(request, metadata=metadata)
    for order in response.orders:
        print(order)

if __name__ == '__main__':
    fetch_user_orders()
```

```java java
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.Metadata;
import io.grpc.stub.MetadataUtils;
import common.ListRequest;
import port.PortServiceGrpc;
import port.AllOrdersResponse;
import port.OrderResponse;

public class UserOrdersFetcher {
    public static void main(String[] args) {
        ManagedChannel channel = ManagedChannelBuilder.forAddress("trade.pfex.io", 443)
            .useTransportSecurity()
            .build();

        Metadata metadata = new Metadata();
        Metadata.Key<String> apiKey = Metadata.Key.of("api-key", Metadata.ASCII_STRING_MARSHALLER);
        metadata.put(apiKey, API_KEY);

        PortServiceGrpc.PortServiceBlockingStub stub =
            PortServiceGrpc.newBlockingStub(channel)
                .withInterceptors(MetadataUtils.newAttachHeadersInterceptor(metadata));

        ListRequest request = ListRequest.newBuilder()
            .setLimit(50)
            .build();

        AllOrdersResponse response = stub.getUserOrders(request);
        for (OrderResponse order : response.getOrdersList()) {
            System.out.println(order);
        }

        channel.shutdown();
    }
}
```

```go go
package main

import (
    "context"
    "fmt"
    "log"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials"
    "google.golang.org/grpc/metadata"
    pbCommon "path/to/proto/common"
    pbPort "path/to/proto/port"
)

func main() {
    creds := credentials.NewClientTLSFromCert(nil, "")
    conn, err := grpc.Dial("trade.pfex.io:443", grpc.WithTransportCredentials(creds))
    if err != nil {
        log.Fatalf("did not connect: %v", err)
    }
    defer conn.Close()

    client := pbPort.NewPortServiceClient(conn)
    ctx := metadata.AppendToOutgoingContext(context.Background(), "api-key", API_KEY)

    req := &pbCommon.ListRequest{Limit: 50}
    resp, err := client.GetUserOrders(ctx, req)
    if err != nil {
        log.Fatalf("error on GetUserOrders: %v", err)
    }

    for _, order := range resp.GetOrders() {
        fmt.Println(order)
    }
}
```

```javascript node
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');

// Load proto definitions
const commonDef = protoLoader.loadSync('common.proto', { keepCase: true, longs: String, enums: String, defaults: true, oneofs: true });
const portDef = protoLoader.loadSync('port.proto', { keepCase: true, longs: String, enums: String, defaults: true, oneofs: true });
const commonProto = grpc.loadPackageDefinition(commonDef).common;
const portProto = grpc.loadPackageDefinition(portDef).port;

function fetchUserOrders(limit = 50) {
  const client = new portProto.PortService(
    'trade.pfex.io:443',
    grpc.credentials.createSsl()
  );

  const metadata = new grpc.Metadata();
  metadata.add('api-key', API_KEY);

  client.getUserOrders({ limit }, metadata, (err, response) => {
    if (err) {
      console.error(err);
      return;
    }
    response.orders.forEach(order => console.log(order));
  });
}

fetchUserOrders();
```
</CodeGroup>
